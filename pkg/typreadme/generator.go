package typreadme

import (
	"fmt"
	"io"

	"github.com/iancoleman/strcase"
	"github.com/typical-go/typical-go/pkg/typbuildtool"
	"github.com/typical-go/typical-go/pkg/typctx"
	"github.com/typical-go/typical-go/pkg/typobj"
	"github.com/typical-go/typical-go/pkg/utility/coll"
	"github.com/typical-go/typical-rest-server/pkg/typreadme/markdown"
	"github.com/urfave/cli/v2"
)

// Generator responsible to generate readme
type Generator struct{}

// Generate readme
func (Generator) Generate(ctx *typctx.Context, w io.Writer) (err error) {
	md := &markdown.Markdown{Writer: w}
	md.Comment("Autogenerated by Typical-Go. DO NOT EDIT.")
	md.H1(ctx.Name)
	if ctx.Description != "" {
		md.Writeln(ctx.Description)
	}

	md.H3("Usage")
	appName := strcase.ToKebab(ctx.Name)
	if typobj.IsActionable(ctx.AppModule) {
		md.Writef("- `%s`: Run the application\n", appName)
	}
	if commander, ok := ctx.AppModule.(typobj.AppCommander); ok {
		for _, cmd := range commander.AppCommands(&dummyCli{}) {
			md.Writef("- `%s %s`: %s\n", appName, cmd.Name, cmd.Usage)
			for _, subcmd := range cmd.Subcommands {
				md.Writef("\t- `%s %s %s`: %s\n", appName, cmd.Name, subcmd.Name, subcmd.Usage)
			}
		}
	}
	md.WriteString("\n")
	keys, fieldMap := fields(ctx)
	keys.Sort()
	if len(keys) > 0 {
		md.H3("Configuration")
		md.WriteString("| Name | Type | Default | Required |\n")
		md.WriteString("|---|---|---|:---:|\n")
		for _, key := range keys {
			var required string
			field := fieldMap[key]
			if field.Required {
				required = "Yes"
			}
			md.WriteString(fmt.Sprintf("|%s|%s|%s|%s|\n", field.Name, field.Type, field.Default, required))
		}
		md.WriteString("\n")
	}

	md.Hr()
	md.H2("Development Guide")

	md.H3("Prerequisite")
	md.Writeln("Install [Go](https://golang.org/doc/install) (It is recommend to install via [Homebrew](https://brew.sh/) `brew install go`)")

	md.H3("Build & Run")
	md.Writeln("Use `./typicalw run` to build and run the project.")

	md.H3("Test")
	md.Writeln("Use `./typicalw test` to test the project.")

	md.H3("Release the destribution")
	md.Writeln("Use `./typicalw release` to make the release. [Learn More](https://typical-go.github.io/learn-more/build-tool/release-distribution.html)")

	for i, cmd := range typbuildtool.BuildCommands(ctx) {
		if i < 1 {
			md.H3("Other Command")
		}
		md.Writef("- `./typicalw %s`: %s\n", cmd.Name, cmd.Usage)
		for _, subcmd := range cmd.Subcommands {
			md.Writef("\t- `./typicalw %s %s`: %s\n", cmd.Name, subcmd.Name, subcmd.Usage)
		}
	}
	return
}

func fields(ctx *typctx.Context) (keys coll.Strings, m map[string]typobj.Field) {
	m = make(map[string]typobj.Field)
	for _, module := range ctx.AllModule() {
		if configurer, ok := module.(typobj.Configurer); ok {
			prefix, spec, _ := configurer.Configure()
			for _, field := range typobj.Fields(prefix, spec) {
				m[field.Name] = field
				keys.Append(field.Name)
			}
		}
	}
	return
}

type dummyCli struct{}

func (*dummyCli) Action(fn interface{}) func(ctx *cli.Context) error {
	return func(ctx *cli.Context) error {
		return nil
	}
}

func (*dummyCli) PreparedAction(fn interface{}) func(ctx *cli.Context) error {
	return func(ctx *cli.Context) error {
		return nil
	}
}
