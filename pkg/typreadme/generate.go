package typreadme

import (
	"fmt"
	"io"
	"os"
	"sort"

	"github.com/iancoleman/strcase"
	"github.com/typical-go/typical-go/pkg/typbuildtool"
	"github.com/typical-go/typical-go/pkg/typcore"
	"github.com/typical-go/typical-rest-server/pkg/typreadme/markdown"
	"github.com/urfave/cli/v2"
)

func (r *readme) generateCmd() *cli.Command {
	return &cli.Command{
		Name:  "readme",
		Usage: "Generate README.md",
		Action: func(c *cli.Context) (err error) {
			var file *os.File
			if file, err = os.Create("README.md"); err != nil {
				return
			}
			defer file.Close()
			if err = generate(file, nil); err != nil {
				return
			}
			return
		},
	}
}

func (r *readme) readmeObj() *ReadmeObject {
	return &ReadmeObject{
		Title:               r.Name,
		Description:         r.Description,
		ApplicationCommands: r.appCommands(),
		OtherBuildCommands:  r.otherCommands(),
		Configs:             r.configs(),
	}
}

func (r *readme) appCommands() (details CommandDetails) {
	appName := strcase.ToKebab(r.Name) // TODO: use typenv instead
	if typcore.IsActionable(r.AppModule) {
		details.Add(&CommandDetail{
			Snippet: appName,
			Usage:   "Run the application",
		})
	}
	if commander, ok := r.AppModule.(typcore.AppCommander); ok {
		for _, cmd := range commander.AppCommands(&typcore.Context{}) {
			addCliCommandDetail(&details, appName, cmd)
		}
	}
	return
}

func (r *readme) otherCommands() (details CommandDetails) {
	for _, cmd := range typbuildtool.BuildCommands(r.ProjectDescriptor) {
		addCliCommandDetail(&details, "./typicalw", cmd)
	}
	return
}

func (r *readme) configs() (details typcore.ConfigDetails) {
	keys, configMap := typcore.CreateConfigMap(r.ProjectDescriptor)
	sort.Strings(keys)
	configMap.ValueBy(keys...)
	return
}

func generate(w io.Writer, o *ReadmeObject) (err error) {
	md := &markdown.Markdown{Writer: w}
	md.Comment("Autogenerated by Typical-Go. DO NOT EDIT.")
	md.H1(o.Title)
	md.Writeln(o.Description)

	md.H3("Usage")
	for _, d := range o.ApplicationCommands {
		md.Writef("- `%s`: %s\n", d.Snippet, d.Usage)
	}
	md.WriteString("\n")
	if len(o.Configs) > 0 {
		md.H3("Configuration")
		md.WriteString("| Name | Type | Default | Required |\n")
		md.WriteString("|---|---|---|:---:|\n")
		for _, cfg := range o.Configs {
			var required string
			if cfg.Required {
				required = "Yes"
			}
			md.WriteString(fmt.Sprintf("|%s|%s|%s|%s|\n", cfg.Name, cfg.Type, cfg.Default, required))
		}
		md.WriteString("\n")
	}

	md.Hr()
	md.H2("Development Guide")

	md.H3("Prerequisite")
	md.Writeln("Install [Go](https://golang.org/doc/install) (It is recommend to install via [Homebrew](https://brew.sh/) `brew install go`)")

	md.H3("Build & Run")
	md.Writeln("Use `./typicalw run` to build and run the project.")

	md.H3("Test")
	md.Writeln("Use `./typicalw test` to test the project.")

	md.H3("Release the destribution")
	md.Writeln("Use `./typicalw release` to make the release. [Learn More](https://typical-go.github.io/learn-more/build-tool/release-distribution.html)")

	md.H3("Other Command")
	for _, cmd := range o.OtherBuildCommands {
		md.Writef("- `%s`: %s\n", cmd.Snippet, cmd.Usage)

	}
	return
}

func addCliCommandDetail(details *CommandDetails, name string, cmd *cli.Command) {
	details.Add(&CommandDetail{
		Snippet: fmt.Sprintf("%s %s", name, cmd.Name),
		Usage:   cmd.Usage,
	})
	for _, subcmd := range cmd.Subcommands {
		details.Add(&CommandDetail{
			Snippet: fmt.Sprintf("%s %s %s", name, cmd.Name, subcmd.Name),
			Usage:   subcmd.Usage,
		})
	}
}
